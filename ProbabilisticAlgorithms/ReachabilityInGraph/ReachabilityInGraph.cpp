/**
В ориентированном графе ориентированным маршрутом или просто маршрутом называется чередующаяся последовательность
v0, (v0, v1), v1, (v1, v2), …, vk вершин и дуг, где каждая дуга идёт от вершины — предыдущего элемента, к вершине — следующему элементу. 
Маршрут, начинающийся в вершине v и заканчивающийся в вершине u также называется (v, u)-маршрутом.
Вершина u называется достижимой из вершины v, если существует (v, u)-маршрут.
(Вершина v всегда достижима из самой себя, поскольку существует (v, v)-маршрут, состоящий только из вершины v.)

Необходимо в заданном ориентированном графе для каждой вершины найти 2-приближённое число достижимых из неё вершин. 
Это значит, что если настоящее число достижимых вершин равно a, то для ответа b должны выполняться неравенства: a ≤ 2b и b ≤ 2a. 
Кроме того, допустимо не более чем для 10 вершин вывести ответ, не удовлетворяющей указанным ограничениям.

Формат входных данных
В первой строке заданы число n вершин и число m дуг графа (1 ≤ n, m ≤ 200 000).
Далее в m строках перечислены дуги графа: 
i-я из этих строк содержит два целых числа vi и ui — начало и конец i-й дуги (1 ≤ vi, ui ≤ n, vi ≠ ui). 
Каждая дуга (v, u) встречается во входных данных не более одного раза.

Формат выходных данных
Выведите n строк, в i-й из которых содержится оценка на число вершин, достижимых из вершины i.
Пример
reachability.in	
5 6
1 2
1 3
2 4
2 5
3 5
4 2
reachability.out
7
3
2
2
1
Замечание
В примере из вершины 1 достижимы все 5 вершин. Однако показанный ответ 7 тоже допустим,
так как отличается от 5 не более, чем в два раза. Аналогично допустимым является ответ 2 для вершины 4.
*/

#include <vector>
#include <iostream>
#include <fstream>

using namespace std;

vector < vector<int> > graph, gr;
vector<char> used;
vector<int> order, component;


void dfs(int vertice) {
	used[vertice] = true;
	for (size_t i = 0; i < graph[vertice].size(); ++i)
		if (!used[graph[vertice][i]])
			dfs(graph[vertice][i]);
	order.push_back(vertice);
}


int main() {
	ifstream input("reachability.in", std::ifstream::in);
	ofstream output("reachability.out");
	int n, m;
	input >> n >> m;
	
	graph.reserve(n);

	int v, u;

	for (size_t i = 0; i < m; i++)
	{	
		input >> v >> u;
		graph[v]
	}
	


	return 0;
}